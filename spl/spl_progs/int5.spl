alias physicalSP S0;
physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);

// Get system call no. from the stack and put it in a register
alias sysCallNo S1;

sysCallNo = [physicalSP - 1];

// Get arguments from stack and put it in registers

if ( sysCallNo == 8) then
// Implementation of Fork 
	//Finding a free PCB
	alias newPID S2;
	newPID = 0;
	while(newPID < 32) do
		if([READY_LIST + newPID*32 + 1] == 0) then
			break;
		endif;
		newPID = newPID + 1;
	endwhile;
	if(newPID == 32) then
		[physicalSP - 2] = -1;
		ireturn;
	endif;
	[READY_LIST + newPID*32] = newPID; //Set PIDA
	[READY_LIST + newPID*32 + 1] = 1; 	//state = ready
	[READY_LIST + newPID*32 + 5] = PAGE_TABLE + newPID*8; //Set PTBR
	[READY_LIST + newPID*32 + 6] = 4; //Set PTLR
 	[READY_LIST + newPID*32 + 4] = [physicalSP]; //Set IP
	[READY_LIST + newPID*32 + 3] = SP - 1;
	[READY_LIST + newPID*32 + 2] = BP;
	[READY_LIST + newPID*32 + 7] = R0;
	[READY_LIST + newPID*32 + 8] = R1;
	[READY_LIST + newPID*32 + 9] = R2;
	[READY_LIST + newPID*32 +10] = R3;
	[READY_LIST + newPID*32 +11] = R4;
	[READY_LIST + newPID*32 +12] = R5;
	[READY_LIST + newPID*32 +13] = R6;
	[READY_LIST + newPID*32 +14] = R7;
	[READY_LIST + newPID*32 + 31] = (PTBR - PAGE_TABLE)/8;
	alias counter S3;
	counter = 15;
	while (counter < 30) do
		[READY_LIST + newPID*32 + counter] = [READY_LIST + (PTBR - PAGE_TABLE)/8*32 + counter];
		[READY_LIST + newPID*32 + counter + 1] = [READY_LIST + (PTBR - PAGE_TABLE)/8*32 + counter + 1];
		if([READY_LIST + (PTBR - PAGE_TABLE)/8*32 + counter] != -1) then
			[FILE_TABLE + [READY_LIST + (PTBR - PAGE_TABLE)/8*32 + counter]*2 + 1] = [FILE_TABLE + [READY_LIST + (PTBR - PAGE_TABLE)/8*32 + counter]*2 + 1] + 1;
		endif;
		counter = counter + 2;
	endwhile;

	


	counter = 0;
	alias pagesRequired S4;
	//count the number of pages required, which is equal to the number of valid pages
	pagesRequired = 0;
	while(counter < PTLR) do
		if ([PTBR + counter*2 + 1] == "01" || [PTBR + counter*2 + 1] == "11") then //Does == work for strings?
			pagesRequired = pagesRequired + 1;
		endif;
		counter = counter+1;
	endwhile;

	//check if required number of free pages are present in memory
	counter = 0;
	while(counter < 64 && pagesRequired != 0) do
		if ([MEM_LIST + counter] == 0) then
			pagesRequired = pagesRequired - 1;
		endif;
		counter = counter + 1;
	endwhile;

	if (pagesRequired != 0) then
		print("Out of free memory");
		[physicalSP - 2] = -1;
		ireturn;
	endif;

	//initially make a full copy of Pagetable and then modify the page number later
	alias newPTBR S9;
	newPTBR = PAGE_TABLE + newPID*8;
	counter = 0;
	while(counter < 8) do
		[newPTBR + counter] = [PTBR + counter];
		counter = counter + 1;
	endwhile;
	//copy pages for new process;
	counter = 0;
	while(counter < PTLR) do
		alias oldLocation S8;
		oldLocation = [PTBR + counter*2];
		if([PTBR + counter*2 + 1] == "01" || [PTBR + counter*2 + 1] == "11") then
			alias counter2 S5;
			while(counter2 < 64) do
				if([MEM_LIST + counter2] == 0) then
					alias counter3 S7;
					counter3 = 0;
					while(counter3 < 512) do
						[counter2*512 + counter3] = [oldLocation*512 + counter3];
						counter3 = counter3 + 1;
					endwhile;
					[newPTBR + counter*2] = counter2;
					[MEM_LIST + counter2] = 1;
					break;
				endif;
				counter2 = counter2 + 1;
			endwhile;
		endif;
		counter = counter + 1;
	endwhile;
	
	[physicalSP - 2] = newPID;
	[[newPTBR + 2*SP/512]*512 + (SP - 1)%512 -1] = -2;
	ireturn;
endif;	
